---
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import FormattedDate from "../../components/FormattedDate.astro";
import readingTime from "reading-time";
import { PenTool, RotateCcw, Code, Lightbulb, Notebook, Youtube } from "lucide-astro";
import { TAG_GROUPS } from "../../config/tagGroups";

const capitalize = (s: string) => {
  if (typeof s !== "string" || !s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
};

// Map post types to their corresponding icons
const getIconForType = (type: string) => {
  const icons = {
    'article': PenTool,
    'retro': RotateCcw,
    'project': Code,
    'idea': Lightbulb,
    'note': Notebook,
    'talk': Youtube,
  };
  return icons[type as keyof typeof icons];
};

const posts = (await getCollection("ideas"))
  .filter((post) => {
    // In development, show all posts including drafts
    // In production, only show published posts (not drafts)
    return import.meta.env.DEV || !post.data.draft;
  })
  .sort((a, b) => {
    const aDate = a.data.pubDate || a.data.date;
    const bDate = b.data.pubDate || b.data.date;
    return new Date(bDate || 0).valueOf() - new Date(aDate || 0).valueOf();
  });

const allTags = [
  ...new Set(posts.flatMap((post) => post.data.tags || [])),
].sort((a, b) => a.localeCompare(b));

function buildGroupedTags(tags: string[], groups: Record<string, string[]>) {
  const seen = new Set<string>();
  const result: Array<{ group: string; tags: string[] }> = [];
  for (const [group, groupTags] of Object.entries(groups)) {
    const ordered = groupTags.filter((t) => tags.includes(t));
    if (ordered.length > 0) {
      result.push({ group, tags: ordered });
      ordered.forEach((t) => seen.add(t));
    }
  }
  const other = tags.filter((t) => !seen.has(t));
  if (other.length > 0) result.push({ group: "Other", tags: other });
  return result;
}

const groupedTags = buildGroupedTags(allTags, TAG_GROUPS);

const allTypes = [
  ...new Set(posts.map((post) => post.data.type).filter(Boolean)),
];
const allStatuses = [
  ...new Set(posts.map((post) => post.data.status).filter(Boolean)),
];

const allPostsData = posts.map((post) => {
  const slug = post.id.replace(/(\/index)?\.(md|mdx)$/, "");
  const stats = readingTime(post.body || "");
  return {
    id: post.id,
    slug: slug,
    title: post.data.title,
    description: post.data.description,
    date: post.data.date,
    updated: post.data.updated,
    type: post.data.type,
    status: post.data.status,
    tags: post.data.tags || [],
    image: post.data.image,
    draft: post.data.draft,
    readingTimeText: stats.text,
    parent: post.data.parent,
  };
});

// Group posts by parent relationship
const childrenByParent = new Map<string, typeof allPostsData>();
allPostsData.forEach((post) => {
  if (post.parent) {
    if (!childrenByParent.has(post.parent)) {
      childrenByParent.set(post.parent, []);
    }
    childrenByParent.get(post.parent)!.push(post);
  }
});

// Create hierarchical structure: top-level posts with their children
const hierarchicalPosts = allPostsData
  .filter((post) => !post.parent) // Only top-level posts
  .map((post) => {
    const children = childrenByParent.get(post.slug) || [];
    // Sort children chronologically (oldest to newest)
    children.sort((a, b) => {
      const aDate = a.date;
      const bDate = b.date;
      return new Date(aDate || 0).valueOf() - new Date(bDate || 0).valueOf();
    });
    return {
      ...post,
      children,
    };
  });
---

<BaseLayout title="Ideas">
  <style>
    .hero {
      padding: 2rem 0;
    }
    .hero h1 {
      font-size: 4rem;
      margin-bottom: 1rem;
    }
    .select-filters {
      display: flex;
      margin-bottom: 1rem;
    }

    .select-filters select {
      background: none;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 1.25rem;
      cursor: pointer;
      background: rgba(var(--gray-light), 0.8);
    }
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      list-style: none;
      padding: 0;
      margin: 0;
      margin-bottom: 2rem;
    }
    .tag-list button {
      background: none;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: capitalize;
      color: var(--sol-8);
      white-space: nowrap;
    }

    .tag-list button:hover {
      color: var(--sol-8);
      background-color: var(--base4);
    }

    :global([data-effective-theme="dark"]) .tag-list button:hover {
      color: var(--black);
      background-color: var(--base01);
    }

    .tag-list button.active {
      background-color: var(--accent);
      color: var(--black);
    }
    .tag-group-outer {
      width: 100%;
      list-style: none;
      position: relative;
    }
    .tag-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.25rem;
    }
    @media (max-width: 767px) {
      .tag-group {
        flex-wrap: nowrap;
        overflow-x: auto;
        scrollbar-width: none;
      }
      .tag-group::-webkit-scrollbar {
        display: none;
      }
      .tag-group.has-overflow-right {
        -webkit-mask-image: linear-gradient(to right, black calc(100% - 3rem), transparent 100%);
        mask-image: linear-gradient(to right, black calc(100% - 3rem), transparent 100%);
      }
      .tag-group.has-overflow-left {
        -webkit-mask-image: linear-gradient(to right, transparent 0%, black 3rem);
        mask-image: linear-gradient(to right, transparent 0%, black 3rem);
      }
      .tag-group.has-overflow-left.has-overflow-right {
        -webkit-mask-image: linear-gradient(to right, transparent 0%, black 3rem, black calc(100% - 3rem), transparent 100%);
        mask-image: linear-gradient(to right, transparent 0%, black 3rem, black calc(100% - 3rem), transparent 100%);
      }
      .tag-group-outer.has-overflow-right::after,
      .tag-group-outer.has-overflow-left::before {
        position: absolute;
        top: -4px;
        bottom: 0;
        display: flex;
        align-items: center;
        font-size: 1.5rem;
        color: var(--sol-8);
        opacity: 0.6;
        pointer-events: none;
      }
      .tag-group-outer.has-overflow-right::after {
        content: '›';
        right: 0.3rem;
      }
      .tag-group-outer.has-overflow-left::before {
        content: '‹';
        left: 0.3rem;
      }
    }
    .tag-group-label {
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--sol-8);
      opacity: 0.45;
      padding: 0 0.25rem 0 0.5rem;
      pointer-events: none;
      white-space: nowrap;
    }
    .select-filters {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    .select-filters select {
      text-transform: capitalize;
      color: var(--black);
    }
    #all-tags {
      background: rgba(var(--gray-light), 0.8);
      border: none;
      border-radius: 4px;
      padding: 0.25rem 1.25rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      text-transform: capitalize;
      color: var(--black);
      white-space: nowrap;
    }
    #all-tags.active {
      background-color: var(--accent);
      color: var(--black);
    }
    .post-grid {
      display: flex;
      gap: 2rem;
      align-items: flex-start;
      flex-direction: column;
    }

    @media (min-width: 768px) {
      .post-grid {
        flex-direction: row;
      }
    }

    .masonry-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      width: 100%;
    }

    @media (min-width: 768px) {
      .masonry-column {
        width: auto;
      }
    }

    /* Without JS, only show first column (server-rendered) */
    .masonry-column[data-column="1"],
    .masonry-column[data-column="2"] {
      display: none;
    }

    /* With JS, show columns based on screen size */
    .js-enabled .masonry-column[data-column="1"] {
      display: flex;
    }

    @media (min-width: 1200px) {
      .js-enabled .masonry-column[data-column="2"] {
        display: flex;
      }
    }

    /* Hide columns on smaller screens even with JS */
    @media (max-width: 767px) {
      .js-enabled .masonry-column[data-column="1"],
      .js-enabled .masonry-column[data-column="2"] {
        display: none;
      }
    }

    @media (min-width: 768px) and (max-width: 1199px) {
      .js-enabled .masonry-column[data-column="2"] {
        display: none;
      }
    }
    .post-card {
      border: 1px solid var(--main-border-color);
      background-color: var(--base4);
      border-radius: 8px;
      overflow: hidden;
      color: inherit;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease-in-out;
    }

    .post-card:focus-within {
      outline: 2px solid var(--blue);
      outline-offset: 2px;
    }

    .post-card:has(.post-card-link:focus:not(:focus-visible)) {
      outline: none;
    }

    .post-card-link {
      text-decoration: none;
      color: inherit;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease-in-out;
    }

    .post-card-link:hover {
      opacity: 0.8;
    }

    .post-card-link:focus {
      outline: none;
    }

    :global([data-effective-theme="dark"]) .post-card {
      border: 1px solid var(--base03);
      background-color: var(--base02);
    }

    .post-card.hidden {
      display: none;
    }

    .post-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
    }

    /* Child posts container - inside parent card */
    .child-posts {
      display: flex;
      flex-direction: column;
      gap: 0;
      border-top: 1px solid var(--main-border-color);
    }

    :global([data-effective-theme="dark"]) .child-posts {
      border-top-color: var(--base03);
    }

    /* Individual child post items */
    .child-post-item {
      display: flex;
      flex-direction: row;
      text-decoration: none;
      color: inherit;
      font-size: 0.9rem;
      border-bottom: 1px solid var(--main-border-color);
      transition: all 0.2s ease-in-out;
    }

    .child-post-item:last-child {
      border-bottom: none;
    }

    .child-post-item.hidden {
      display: none;
    }

    .child-post-item:hover {
      opacity: 0.8;
    }

    .child-post-item:focus {
      outline: 2px solid var(--blue);
      outline-offset: 2px;
    }

    .child-post-item:focus:not(:focus-visible) {
      outline: none;
    }

    :global([data-effective-theme="dark"]) .child-post-item {
      border-bottom-color: var(--base03);
    }

    .child-post-content {
      padding: 0.75rem;
      flex: 1;
    }

    .child-post-content h3 {
      font-size: 1rem;
      margin-bottom: 0.25rem;
    }

    .child-post-content p {
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }

    .child-post-item img {
      width: 120px;
      height: 100%;
      min-height: 100px;
      max-height: 120px;
      object-fit: cover;
      flex-shrink: 0;
    }
    .post-card-content {
      padding: 1rem;
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    .post-card-content h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
    }
    .post-card-content p {
      margin: 0 0 1rem 0;
      flex-grow: 1;
      font-size: 1rem;
    }

    .post-card-content-header span {
      padding-right: 1em;
    }

    .post-meta,
    .post-card-content-header {
      font-size: 0.75rem;
      text-transform: capitalize;
      color: var(--sol-7);
      margin-bottom: 0.5rem;
      display: flex;
    }

    .type-with-icon {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .type-with-icon svg {
      flex-shrink: 0;
      vertical-align: middle;
    }

        /* Retro posts - larger, more prominent */
    .post-card--retro {
      /* border-width: 2px;
      border-color: var(--accent); */
    }

    .post-card--retro .post-card-content {
      /* padding: 1.5rem; */
    }

    .post-card--retro .post-card-content h3 {
      font-size: 1.75rem;
      font-weight: 700;
      margin-bottom: 0.75rem;
    }

    .post-card--retro .post-card-content p {
      font-size: 1.05rem;
      line-height: 1.6;
    }

    .post-card--retro img {
      height: 300px;
    }

    :global([data-effective-theme="dark"]) .post-card--retro {
      /* border-color: var(--accent); */
    }

    /* Note posts - compact, minimal */
    .post-card--note {
      /* background-color: var(--base3);
      border-style: dashed;
      border-color: var(--sol-7); */
    }

    :global([data-effective-theme="dark"]) .post-card--note {
      /* background-color: var(--base01);
      border-color: var(--sol-7); */
    }

    .post-card--note .post-card-content {
      padding: 0.75rem;
    }

    .post-card--note .post-card-content h3 {
      font-size: 1rem;
      font-weight: 500;
    }

    .post-card--note .post-card-content p {
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    /* Hide images in note cards */
    .post-card--note img {
      display: none;
    }

    /* Project posts - standard with slight emphasis */
    .post-card--project {
      /* border-left-width: 3px;
      border-left-color: var(--sol-blue); */
    }

    /* Article posts - standard style (default) */
    .post-card--article {
      /* Uses default post-card styles */
    }

    /* Talk posts - similar to article but with subtle distinction */
    .post-card--talk {
      /* Uses default post-card styles with subtle border accent */
      /* border-left-width: 3px; */
      /* border-left-color: var(--sol-magenta); */
    }

    .draft-indicator {
      background-color: var(--sol-yellow);
      color: var(--green);
      font-size: 0.6rem;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .child-count {
      background-color: var(--sol-blue);
      color: var(--base3);
      font-size: 0.6rem;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: none;
      letter-spacing: 0.5px;
    }

    .post-meta {
      display: flex;
      justify-content: space-between;
    }

    .slide-in-block {
      opacity: 0;
      filter: blur(10px);
      transform: scale(0.95);
      will-change: transform, opacity, filter;
      animation: slideInBlock 0.4s cubic-bezier(0.43, 0.195, 0.02, 1) forwards;
    }

    .slide-in-block:nth-child(1) {
      /* animation-delay: 0.3s; */
    }
    .slide-in-block:nth-child(2) {
      animation-delay: 0.2s;
    }
    @keyframes slideInBlock {
      to {
        opacity: 1;
        filter: blur(0px);
        transform: scale(1);
      }
    }
  </style>

  <header class="slide-in-block">
    <div class="hero">
      <h1>Digital Garden</h1>
      <p>The notes, thoughts, and projects I've been working on.</p>
    </div>

    <div class="js-required">
      <div class="select-filters">
        <button class="active" id="all-tags">All Topics</button>
        <select id="type-filter">
          <option value="all">All types</option>
          {allTypes.map((type) => <option value={type}>{capitalize(type || '')}</option>)}
        </select>
        <select id="status-filter">
          <option value="all">All statuses</option>
          {
            allStatuses.map((status) => (
              <option value={status}>{capitalize(status || '')}</option>
            ))
          }
        </select>
      </div>

      <div class="filters" data-pagefind-ignore>
        <ul class="tag-list">
          {
            groupedTags.map(({ group, tags }) => (
              <li class="tag-group-outer">
                <div class="tag-group">
                  <span class="tag-group-label" aria-hidden="true">{group}</span>
                  {tags.map((tag) => (
                    <button data-tag={tag}>{tag}</button>
                  ))}
                </div>
              </li>
            ))
          }
        </ul>
      </div>
    </div>
  </header>

  <section class="post-grid slide-in-block" data-pagefind-ignore>
    <!-- Server-rendered single column - works without JS -->
    <div class="masonry-column" data-column="0">
      {
        hierarchicalPosts.map((post) => {
        const typeClass = post.type ? `post-card--${post.type}` : '';
        const isRetro = post.type === 'retro';
        const hasChildren = post.children && post.children.length > 0;

        return (
          <div
            class={`post-card ${typeClass} ${hasChildren ? "post-card--with-children" : ""}`}
            data-parent-slug={post.slug}
            data-tags={post.tags?.join(" ")}
            data-type={post.type}
            data-status={post.status}
            data-has-parent="false"
          >
            {/* Parent post link and content */}
            <a
              href={`/ideas/${post.slug}/`}
              class="post-card-link"
            >
              {/* Show image at top for all posts */}
              {post.image?.path && (
                <Image
                  src={post.image.path}
                  alt={post.image.alt || ""}
                  width={800}
                  height={isRetro ? 300 : 200}
                />
              )}

              <div class="post-card-content">
                <div class="post-card-content-header">
                  {post.draft && <span class="draft-indicator">DRAFT</span>}
                  {post.type && (
                    <span class="type-with-icon">
                      {(() => {
                        const Icon = getIconForType(post.type);
                        return Icon ? <Icon size={14} /> : null;
                      })()}
                      {capitalize(post.type)}
                    </span>
                  )}
                  {post.status && <span>{capitalize(post.status)}</span>}
                  <span>{post.readingTimeText}</span>
                </div>
                <h3>{post.title}</h3>
                <p>{post.description}</p>
                <div class="post-meta">
                  <span>
                    <FormattedDate date={post.date || new Date()} />
                  </span>
                  {post.updated && (
                    <span>
                      Updated: <FormattedDate date={post.updated} />
                    </span>
                  )}
                </div>
              </div>
            </a>

            {/* Child posts - inside the same card */}
            {hasChildren && (
              <div class="child-posts" data-parent={post.slug}>
                {post.children.map((child) => {
                  const childTypeClass = child.type ? `post-card--${child.type}` : '';

                  return (
                    <a
                      href={`/ideas/${child.slug}/`}
                      class={`child-post-item ${childTypeClass}`}
                      data-tags={child.tags?.join(" ")}
                      data-type={child.type}
                      data-status={child.status}
                      data-has-parent="true"
                      data-parent-post={post.slug}
                    >
                      {/* Show image on left for child posts */}
                      {child.image?.path && (
                        <Image
                          src={child.image.path}
                          alt={child.image.alt || ""}
                          width={400}
                          height={120}
                        />
                      )}

                      <div class="child-post-content">
                        <div class="post-card-content-header">
                          {child.draft && <span class="draft-indicator">DRAFT</span>}
                          {child.type && (
                            <span class="type-with-icon">
                              {(() => {
                                const Icon = getIconForType(child.type);
                                return Icon ? <Icon size={14} /> : null;
                              })()}
                              {capitalize(child.type)}
                            </span>
                          )}
                          {child.status && <span>{capitalize(child.status)}</span>}
                          <span>{child.readingTimeText}</span>
                        </div>
                        <h3>{child.title}</h3>
                        <p>{child.description}</p>
                        <div class="post-meta">
                          <span>
                            <FormattedDate date={child.date || new Date()} />
                          </span>
                          {child.updated && (
                            <span>
                              Updated: <FormattedDate date={child.updated} />
                            </span>
                          )}
                        </div>
                      </div>
                    </a>
                  );
                })}
              </div>
            )}
          </div>
        );
      })
    }
    </div>
    <!-- Additional columns created by JS for masonry layout -->
    <div class="masonry-column" data-column="1"></div>
    <div class="masonry-column" data-column="2"></div>
  </section>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize masonry layout
      const postGrid = document.querySelector('.post-grid') as HTMLElement;
      const columns = Array.from(document.querySelectorAll('.masonry-column')) as HTMLElement[];

      if (!postGrid || columns.length === 0) return;

      // Enable JS-enhanced layout
      postGrid.classList.add('js-enabled');

      // Get all post items from the first column (server-rendered)
      const firstColumn = columns[0];
      const postItems = Array.from(firstColumn.querySelectorAll('.post-card')) as HTMLElement[];
      let lastLayoutWidth = window.innerWidth;

      // Function to get visible columns based on screen width
      function getVisibleColumns() {
        const width = window.innerWidth;
        if (width < 768) return [columns[0]]; // Mobile: 1 column
        if (width < 1200) return [columns[0], columns[1]]; // Tablet: 2 columns
        return columns; // Desktop: 3 columns
      }

      // Distribute items into columns using "shortest column" algorithm
      function layoutMasonry(force = false) {
        const currentWidth = window.innerWidth;
        // Ignore height-only resizes (e.g., mobile address bar hide/show) to avoid jumpy relayouts
        if (!force && currentWidth === lastLayoutWidth) {
          return;
        }

        const visibleColumns = getVisibleColumns();
        lastLayoutWidth = currentWidth;

        // Clear all columns
        columns.forEach(col => col.innerHTML = '');

        // Move existing DOM elements (preserves event listeners and state)
        postItems.forEach((item) => {
          // Skip hidden items (filtered out) - don't count toward column height
          if (item.classList.contains('hidden')) {
            // Still add to a column but keep hidden class
            visibleColumns[0].appendChild(item);
            return;
          }

          // Find the shortest visible column by comparing current heights
          let shortestColumn = visibleColumns[0];
          let shortestHeight = visibleColumns[0].offsetHeight;

          visibleColumns.forEach(col => {
            if (col.offsetHeight < shortestHeight) {
              shortestHeight = col.offsetHeight;
              shortestColumn = col;
            }
          });

          // Add item to shortest column
          shortestColumn.appendChild(item);
        });
      }

      // Initial layout
      layoutMasonry(true);

      // Re-layout on window resize (debounced)
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(layoutMasonry, 150);
      });

      let activeTag = "all";
      let activeType = "all";
      let activeStatus = "all";
      let activeHierarchy = "all";

      function filterPosts() {
        // Use the server-rendered postItems array
        postItems.forEach((container) => {
          // The container itself is now the post-card
          const parentTags = container.dataset.tags?.split(" ") || [];
          const parentType = container.dataset.type;
          const parentStatus = container.dataset.status;

          const parentTagMatch = activeTag === "all" || parentTags.includes(activeTag);
          const parentTypeMatch = activeType === "all" || parentType === activeType;
          const parentStatusMatch = activeStatus === "all" || parentStatus === activeStatus;

          // Check if any children match (if they exist)
          const childContainer = container.querySelector('.child-posts') as HTMLElement;
          let anyChildMatches = false;
          if (childContainer) {
            const childItems = Array.from(childContainer.querySelectorAll('.child-post-item')) as HTMLElement[];
            childItems.forEach((childItem) => {
              const childTags = childItem.dataset.tags?.split(" ") || [];
              const childType = childItem.dataset.type;
              const childStatus = childItem.dataset.status;

              const childTagMatch = activeTag === "all" || childTags.includes(activeTag);
              const childTypeMatch = activeType === "all" || childType === activeType;
              const childStatusMatch = activeStatus === "all" || childStatus === activeStatus;

              if (childTagMatch && childTypeMatch && childStatusMatch) {
                childItem.classList.remove("hidden");
                anyChildMatches = true;
              } else {
                childItem.classList.add("hidden");
              }
            });
          }

          // Show parent if it matches OR if we're showing all posts and any child matches
          const shouldShowParent = (parentTagMatch && parentTypeMatch && parentStatusMatch) ||
                                   (activeHierarchy === "all" && anyChildMatches);

          // For top-level filter, always evaluate parent normally
          if (activeHierarchy === "top-level") {
            if (parentTagMatch && parentTypeMatch && parentStatusMatch) {
              container.classList.remove("hidden");
              // Hide children in top-level mode
              if (childContainer) {
                childContainer.style.display = "none";
              }
            } else {
              container.classList.add("hidden");
            }
          } else {
            // Normal filtering: show parent and children based on matches
            if (shouldShowParent) {
              container.classList.remove("hidden");
              if (childContainer) {
                childContainer.style.display = anyChildMatches ? "flex" : "none";
              }
            } else {
              container.classList.add("hidden");
            }
          }
        });

        // Re-layout masonry after filtering to fix column distribution
        requestAnimationFrame(() => {
          layoutMasonry(true);
        });
      }

      // Tag filtering
      const tagButtons = document.querySelectorAll(".tag-list button");
      const allTagsButton = document.getElementById("all-tags");

      function resetToAllTopics() {
        tagButtons.forEach((btn) => btn.classList.remove("active"));
        allTagsButton?.classList.add("active");
        activeTag = "all";
        history.replaceState(null, "", window.location.pathname);
        filterPosts();
      }

      allTagsButton?.addEventListener("click", resetToAllTopics);

      tagButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const b = button as HTMLElement;
          // Clicking an already-selected tag deselects it (revert to All Topics)
          if (button.classList.contains("active")) {
            resetToAllTopics();
          } else {
            tagButtons.forEach((btn) => btn.classList.remove("active"));
            allTagsButton?.classList.remove("active");
            button.classList.add("active");
            activeTag = b.dataset.tag || "all";
            history.replaceState(null, "", `?tag=${encodeURIComponent(activeTag)}`);
            filterPosts();
          }
        });
      });

      // Type filter
      const typeFilter = document.getElementById(
        "type-filter"
      ) as HTMLSelectElement;
      if (typeFilter) {
        typeFilter.addEventListener("change", (e) => {
          activeType = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }

      // Status filter
      const statusFilter = document.getElementById(
        "status-filter"
      ) as HTMLSelectElement;
      if (statusFilter) {
        statusFilter.addEventListener("change", (e) => {
          activeStatus = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }

      // Activate filter from URL query param (e.g. linked from a post page tag)
      const urlTag = new URLSearchParams(window.location.search).get("tag");
      if (urlTag) {
        const matchingButton = document.querySelector<HTMLElement>(
          `.tag-list button[data-tag="${urlTag}"]`
        );
        if (matchingButton) {
          tagButtons.forEach((btn) => btn.classList.remove("active"));
          allTagsButton?.classList.remove("active");
          matchingButton.classList.add("active");
          activeTag = urlTag;
          filterPosts();
        }
      }
      // Scroll-edge fades + chevrons for mobile tag groups (progressive enhancement)
      function updateScrollFades(el: HTMLElement) {
        const hasLeft = el.scrollLeft > 0;
        const hasRight = el.scrollLeft + el.clientWidth < el.scrollWidth - 1;
        el.classList.toggle("has-overflow-left", hasLeft);
        el.classList.toggle("has-overflow-right", hasRight);
        el.parentElement?.classList.toggle("has-overflow-left", hasLeft);
        el.parentElement?.classList.toggle("has-overflow-right", hasRight);
      }

      document.querySelectorAll<HTMLElement>(".tag-group").forEach((group) => {
        updateScrollFades(group);
        group.addEventListener("scroll", () => updateScrollFades(group), { passive: true });
      });
    });
  </script>
</BaseLayout>

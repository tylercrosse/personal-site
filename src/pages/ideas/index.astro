---
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import FormattedDate from "../../components/FormattedDate.astro";
import readingTime from "reading-time";

const capitalize = (s: string) => {
  if (typeof s !== "string" || !s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
};

const posts = (await getCollection("ideas"))
  .filter((post) => {
    // In development, show all posts including drafts
    // In production, only show published posts (not drafts)
    return import.meta.env.DEV || !post.data.draft;
  })
  .sort((a, b) => {
    const aDate = a.data.pubDate || a.data.date;
    const bDate = b.data.pubDate || b.data.date;
    return new Date(bDate || 0).valueOf() - new Date(aDate || 0).valueOf();
  });

const allTags = [
  ...new Set(posts.flatMap((post) => post.data.tags || [])),
].sort((a, b) => a.localeCompare(b));
const allTypes = [
  ...new Set(posts.map((post) => post.data.type).filter(Boolean)),
];
const allStatuses = [
  ...new Set(posts.map((post) => post.data.status).filter(Boolean)),
];

const allPostsData = posts.map((post) => {
  const slug = post.id.replace(/(\/index)?\.(md|mdx)$/, "");
  const stats = readingTime(post.body || "");
  return {
    id: post.id,
    slug: slug,
    title: post.data.title,
    description: post.data.description,
    date: post.data.date,
    updated: post.data.updated,
    type: post.data.type,
    status: post.data.status,
    tags: post.data.tags || [],
    image: post.data.image,
    draft: post.data.draft,
    readingTimeText: stats.text,
    parent: post.data.parent,
  };
});

// Group posts by parent relationship
const childrenByParent = new Map<string, typeof allPostsData>();
allPostsData.forEach((post) => {
  if (post.parent) {
    if (!childrenByParent.has(post.parent)) {
      childrenByParent.set(post.parent, []);
    }
    childrenByParent.get(post.parent)!.push(post);
  }
});

// Create hierarchical structure: top-level posts with their children
const hierarchicalPosts = allPostsData
  .filter((post) => !post.parent) // Only top-level posts
  .map((post) => {
    const children = childrenByParent.get(post.slug) || [];
    // Sort children chronologically (oldest to newest)
    children.sort((a, b) => {
      const aDate = a.date;
      const bDate = b.date;
      return new Date(aDate || 0).valueOf() - new Date(bDate || 0).valueOf();
    });
    return {
      ...post,
      children,
    };
  });
---

<BaseLayout title="Ideas">
  <style>
    .hero {
      padding: 2rem 0;
    }
    .hero h1 {
      font-size: 4rem;
      margin-bottom: 1rem;
    }
    .select-filters {
      display: flex;
      margin-bottom: 1rem;
    }

    .select-filters select {
      background: none;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 1.25rem;
      cursor: pointer;
      background: rgba(var(--gray-light), 0.8);
    }
    .tag-list {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      list-style: none;
      padding: 0;
      margin: 0;
      margin-bottom: 2rem;
    }
    .tag-list button {
      background: none;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: capitalize;
      color: var(--sol-8);
    }

    .tag-list button:hover {
      color: var(--sol-8);
      background-color: var(--base4);
    }

    :global([data-effective-theme="dark"]) .tag-list button:hover {
      color: var(--black);
      background-color: var(--base01);
    }

    .tag-list button.active {
      background-color: var(--accent);
      color: var(--black);
    }
    .select-filters {
      display: flex;
      gap: 1rem;
    }
    .select-filters select {
      text-transform: capitalize;
      color: var(--black);
    }
    .post-grid {
      display: flex;
      gap: 2rem;
      align-items: flex-start;
      flex-direction: column;
    }

    @media (min-width: 768px) {
      .post-grid {
        flex-direction: row;
      }
    }

    .masonry-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      width: 100%;
    }

    @media (min-width: 768px) {
      .masonry-column {
        width: auto;
      }
    }

    /* Hide columns 2 and 3 on mobile */
    @media (max-width: 767px) {
      .masonry-column[data-column="1"],
      .masonry-column[data-column="2"] {
        display: none;
      }
    }

    /* Hide column 3 on tablet */
    @media (min-width: 768px) and (max-width: 1199px) {
      .masonry-column[data-column="2"] {
        display: none;
      }
    }
    .post-card {
      border: 1px solid var(--main-border-color);
      background-color: var(--base4);
      border-radius: 8px;
      overflow: hidden;
      color: inherit;
      display: flex;
      flex-direction: column;
    }

    .post-card-link {
      text-decoration: none;
      color: inherit;
      display: flex;
      flex-direction: column;
      transition: all 0.2s ease-in-out;
    }

    .post-card-link:hover {
      opacity: 0.8;
    }

    :global([data-effective-theme="dark"]) .post-card {
      border: 1px solid var(--base03);
      background-color: var(--base02);
    }

    .post-card.hidden {
      display: none;
    }

    .post-card img {
      width: 100%;
      height: 200px;
      object-fit: cover;
    }

    /* Child posts container - inside parent card */
    .child-posts {
      display: flex;
      flex-direction: column;
      gap: 0;
      border-top: 1px solid var(--main-border-color);
    }

    :global([data-effective-theme="dark"]) .child-posts {
      border-top-color: var(--base03);
    }

    /* Individual child post items */
    .child-post-item {
      display: flex;
      flex-direction: row;
      text-decoration: none;
      color: inherit;
      font-size: 0.9rem;
      border-bottom: 1px solid var(--main-border-color);
      transition: background-color 0.2s ease-in-out;
    }

    .child-post-item:last-child {
      border-bottom: none;
    }

    .child-post-item.hidden {
      display: none;
    }

    .child-post-item:hover {
      background-color: var(--base3);
    }

    :global([data-effective-theme="dark"]) .child-post-item {
      border-bottom-color: var(--base03);
    }

    :global([data-effective-theme="dark"]) .child-post-item:hover {
      background-color: var(--base01);
    }

    .child-post-content {
      padding: 0.75rem;
      flex: 1;
    }

    .child-post-content h3 {
      font-size: 1rem;
      margin-bottom: 0.25rem;
    }

    .child-post-content p {
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }

    .child-post-item img {
      width: 120px;
      height: 100%;
      min-height: 100px;
      max-height: 120px;
      object-fit: cover;
      flex-shrink: 0;
    }
    .post-card-content {
      padding: 1rem;
      display: flex;
      flex-direction: column;
      flex-grow: 1;
    }
    .post-card-content h3 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
    }
    .post-card-content p {
      margin: 0 0 1rem 0;
      flex-grow: 1;
      font-size: 1rem;
    }

    .post-card-content-header span {
      padding-right: 1em;
    }

    .post-meta,
    .post-card-content-header {
      font-size: 0.75rem;
      text-transform: capitalize;
      color: var(--sol-7);
      margin-bottom: 0.5rem;
    }

        /* Retro posts - larger, more prominent */
    .post-card--retro {
      /* border-width: 2px;
      border-color: var(--accent); */
    }

    .post-card--retro .post-card-content {
      /* padding: 1.5rem; */
    }

    .post-card--retro .post-card-content h3 {
      font-size: 1.75rem;
      font-weight: 700;
      margin-bottom: 0.75rem;
    }

    .post-card--retro .post-card-content p {
      font-size: 1.05rem;
      line-height: 1.6;
    }

    .post-card--retro img {
      height: 300px;
    }

    :global([data-effective-theme="dark"]) .post-card--retro {
      /* border-color: var(--accent); */
    }

    /* Note posts - compact, minimal */
    .post-card--note {
      /* background-color: var(--base3);
      border-style: dashed;
      border-color: var(--sol-7); */
    }

    :global([data-effective-theme="dark"]) .post-card--note {
      background-color: var(--base01);
      border-color: var(--sol-7);
    }

    .post-card--note .post-card-content {
      padding: 0.75rem;
    }

    .post-card--note .post-card-content h3 {
      font-size: 1rem;
      font-weight: 500;
    }

    .post-card--note .post-card-content p {
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    /* Hide images in note cards */
    .post-card--note img {
      display: none;
    }

    /* Project posts - standard with slight emphasis */
    .post-card--project {
      /* border-left-width: 3px;
      border-left-color: var(--sol-blue); */
    }

    /* Article posts - standard style (default) */
    .post-card--article {
      /* Uses default post-card styles */
    }

    .draft-indicator {
      background-color: var(--sol-yellow);
      color: var(--green);
      font-size: 0.6rem;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .child-count {
      background-color: var(--sol-blue);
      color: var(--base3);
      font-size: 0.6rem;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 3px;
      text-transform: none;
      letter-spacing: 0.5px;
    }

    .post-meta {
      display: flex;
      justify-content: space-between;
    }

    .slide-in-block {
      opacity: 0;
      filter: blur(10px);
      transform: scale(0.95);
      will-change: transform, opacity, filter;
      animation: slideInBlock 0.4s cubic-bezier(0.43, 0.195, 0.02, 1) forwards;
    }

    .slide-in-block:nth-child(1) {
      /* animation-delay: 0.3s; */
    }
    .slide-in-block:nth-child(2) {
      animation-delay: 0.2s;
    }
    @keyframes slideInBlock {
      to {
        opacity: 1;
        filter: blur(0px);
        transform: scale(1);
      }
    }
  </style>

  <header class="slide-in-block">
    <div class="hero">
      <h1>Digital Garden</h1>
      <p>The notes, thoughts, and projects I've been working on.</p>
    </div>

    <div class="js-required">
      <div class="select-filters">
        <select id="type-filter">
          <option value="all">All types</option>
          {allTypes.map((type) => <option value={type}>{capitalize(type || '')}</option>)}
        </select>
        <select id="status-filter">
          <option value="all">All statuses</option>
          {
            allStatuses.map((status) => (
              <option value={status}>{capitalize(status || '')}</option>
            ))
          }
        </select>
      </div>

      <div class="filters" data-pagefind-ignore>
        <ul class="tag-list">
          <li><button class="active" id="all-tags">All Topics</button></li>
          {
            allTags.map((tag) => (
              <li>
                <button data-tag={tag}>{tag}</button>
              </li>
            ))
          }
        </ul>
      </div>
    </div>
  </header>

  <section class="post-grid slide-in-block" data-pagefind-ignore>
    <div class="masonry-column" data-column="0"></div>
    <div class="masonry-column" data-column="1"></div>
    <div class="masonry-column" data-column="2"></div>
  </section>

  <!-- Hidden template container for posts -->
  <template id="post-items">
    {
      hierarchicalPosts.map((post) => {
        const typeClass = post.type ? `post-card--${post.type}` : '';
        const isRetro = post.type === 'retro';
        const hasChildren = post.children && post.children.length > 0;

        return (
          <div
            class={`post-card ${typeClass} ${hasChildren ? "post-card--with-children" : ""}`}
            data-parent-slug={post.slug}
            data-tags={post.tags?.join(" ")}
            data-type={post.type}
            data-status={post.status}
            data-has-parent="false"
          >
            {/* Parent post link and content */}
            <a
              href={`/ideas/${post.slug}/`}
              class="post-card-link"
            >
              {/* Show image at top for all posts */}
              {post.image?.path && (
                <Image
                  src={post.image.path}
                  alt={post.image.alt || ""}
                  width={800}
                  height={isRetro ? 300 : 200}
                />
              )}

              <div class="post-card-content">
                <div class="post-card-content-header">
                  {post.draft && <span class="draft-indicator">DRAFT</span>}
                  {post.type && <span>{capitalize(post.type)}</span>}
                  {post.status && <span>{capitalize(post.status)}</span>}
                  <span>{post.readingTimeText}</span>
                </div>
                <h3>{post.title}</h3>
                <p>{post.description}</p>
                <div class="post-meta">
                  <span>
                    <FormattedDate date={post.date || new Date()} />
                  </span>
                  {post.updated && (
                    <span>
                      Updated: <FormattedDate date={post.updated} />
                    </span>
                  )}
                </div>
              </div>
            </a>

            {/* Child posts - inside the same card */}
            {hasChildren && (
              <div class="child-posts" data-parent={post.slug}>
                {post.children.map((child) => {
                  const childTypeClass = child.type ? `post-card--${child.type}` : '';

                  return (
                    <a
                      href={`/ideas/${child.slug}/`}
                      class={`child-post-item ${childTypeClass}`}
                      data-tags={child.tags?.join(" ")}
                      data-type={child.type}
                      data-status={child.status}
                      data-has-parent="true"
                      data-parent-post={post.slug}
                    >
                      {/* Show image on left for child posts */}
                      {child.image?.path && (
                        <Image
                          src={child.image.path}
                          alt={child.image.alt || ""}
                          width={400}
                          height={120}
                        />
                      )}

                      <div class="child-post-content">
                        <div class="post-card-content-header">
                          {child.draft && <span class="draft-indicator">DRAFT</span>}
                          {child.type && <span>{capitalize(child.type)}</span>}
                          {child.status && <span>{capitalize(child.status)}</span>}
                          <span>{child.readingTimeText}</span>
                        </div>
                        <h3>{child.title}</h3>
                        <p>{child.description}</p>
                        <div class="post-meta">
                          <span>
                            <FormattedDate date={child.date || new Date()} />
                          </span>
                          {child.updated && (
                            <span>
                              Updated: <FormattedDate date={child.updated} />
                            </span>
                          )}
                        </div>
                      </div>
                    </a>
                  );
                })}
              </div>
            )}
          </div>
        );
      })
    }
  </template>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize masonry layout
      const postGrid = document.querySelector('.post-grid') as HTMLElement;
      const template = document.getElementById('post-items') as HTMLTemplateElement;
      const columns = Array.from(document.querySelectorAll('.masonry-column')) as HTMLElement[];

      if (!postGrid || !template) return;

      // Get all post items from template
      const postItems = Array.from(template.content.children) as HTMLElement[];

      // Function to get visible columns based on screen width
      function getVisibleColumns() {
        const width = window.innerWidth;
        if (width < 768) return [columns[0]]; // Mobile: 1 column
        if (width < 1200) return [columns[0], columns[1]]; // Tablet: 2 columns
        return columns; // Desktop: 3 columns
      }

      // Distribute items into columns using "shortest column" algorithm
      function layoutMasonry() {
        const visibleColumns = getVisibleColumns();

        // Clear all columns
        columns.forEach(col => col.innerHTML = '');

        postItems.forEach((item) => {
          // Clone the item from template
          const clonedItem = item.cloneNode(true) as HTMLElement;

          // Find the shortest visible column by comparing current heights
          let shortestColumn = visibleColumns[0];
          let shortestHeight = visibleColumns[0].offsetHeight;

          visibleColumns.forEach(col => {
            if (col.offsetHeight < shortestHeight) {
              shortestHeight = col.offsetHeight;
              shortestColumn = col;
            }
          });

          // Add item to shortest column
          shortestColumn.appendChild(clonedItem);
        });
      }

      // Initial layout
      layoutMasonry();

      // Re-layout on window resize (debounced)
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(layoutMasonry, 150);
      });

      let activeTag = "all";
      let activeType = "all";
      let activeStatus = "all";
      let activeHierarchy = "all";

      function filterPosts() {
        // Get containers dynamically since they're recreated on layout
        const parentContainers = Array.from(postGrid.querySelectorAll('.post-card')) as HTMLElement[];

        parentContainers.forEach((container) => {
          // The container itself is now the post-card
          const parentTags = container.dataset.tags?.split(" ") || [];
          const parentType = container.dataset.type;
          const parentStatus = container.dataset.status;

          const parentTagMatch = activeTag === "all" || parentTags.includes(activeTag);
          const parentTypeMatch = activeType === "all" || parentType === activeType;
          const parentStatusMatch = activeStatus === "all" || parentStatus === activeStatus;

          // Check if any children match (if they exist)
          const childContainer = container.querySelector('.child-posts') as HTMLElement;
          let anyChildMatches = false;
          if (childContainer) {
            const childItems = Array.from(childContainer.querySelectorAll('.child-post-item')) as HTMLElement[];
            childItems.forEach((childItem) => {
              const childTags = childItem.dataset.tags?.split(" ") || [];
              const childType = childItem.dataset.type;
              const childStatus = childItem.dataset.status;

              const childTagMatch = activeTag === "all" || childTags.includes(activeTag);
              const childTypeMatch = activeType === "all" || childType === activeType;
              const childStatusMatch = activeStatus === "all" || childStatus === activeStatus;

              if (childTagMatch && childTypeMatch && childStatusMatch) {
                childItem.classList.remove("hidden");
                anyChildMatches = true;
              } else {
                childItem.classList.add("hidden");
              }
            });
          }

          // Show parent if it matches OR if we're showing all posts and any child matches
          const shouldShowParent = (parentTagMatch && parentTypeMatch && parentStatusMatch) ||
                                   (activeHierarchy === "all" && anyChildMatches);

          // For top-level filter, always evaluate parent normally
          if (activeHierarchy === "top-level") {
            if (parentTagMatch && parentTypeMatch && parentStatusMatch) {
              container.classList.remove("hidden");
              // Hide children in top-level mode
              if (childContainer) {
                childContainer.style.display = "none";
              }
            } else {
              container.classList.add("hidden");
            }
          } else {
            // Normal filtering: show parent and children based on matches
            if (shouldShowParent) {
              container.classList.remove("hidden");
              if (childContainer) {
                childContainer.style.display = anyChildMatches ? "flex" : "none";
              }
            } else {
              container.classList.add("hidden");
            }
          }
        });
      }

      // Tag filtering
      const tagButtons = document.querySelectorAll(".tag-list button");
      tagButtons.forEach((button) => {
        button.addEventListener("click", () => {
          tagButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          const b = button as HTMLElement;
          activeTag = b.id === "all-tags" ? "all" : b.dataset.tag || "all";
          filterPosts();
        });
      });

      // Type filter
      const typeFilter = document.getElementById(
        "type-filter"
      ) as HTMLSelectElement;
      if (typeFilter) {
        typeFilter.addEventListener("change", (e) => {
          activeType = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }

      // Status filter
      const statusFilter = document.getElementById(
        "status-filter"
      ) as HTMLSelectElement;
      if (statusFilter) {
        statusFilter.addEventListener("change", (e) => {
          activeStatus = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }
    });
  </script>
</BaseLayout>

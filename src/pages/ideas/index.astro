---
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import FormattedDate from "../../components/FormattedDate.astro";
import readingTime from "reading-time";

const capitalize = (s: string) => {
  if (typeof s !== "string" || !s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
};

const posts = (await getCollection("ideas"))
  .filter((post) => {
    // In development, show all posts including drafts
    // In production, only show published posts (not drafts)
    return import.meta.env.DEV || !post.data.draft;
  })
  .sort((a, b) => {
    const aDate = a.data.pubDate || a.data.date;
    const bDate = b.data.pubDate || b.data.date;
    return new Date(bDate || 0).valueOf() - new Date(aDate || 0).valueOf();
  });

const allTags = [
  ...new Set(posts.flatMap((post) => post.data.tags || [])),
].sort((a, b) => a.localeCompare(b));
const allTypes = [
  ...new Set(posts.map((post) => post.data.type).filter(Boolean)),
];
const allStatuses = [
  ...new Set(posts.map((post) => post.data.status).filter(Boolean)),
];

const allPostsData = posts.map((post) => {
  const slug = post.id.replace(/(\/index)?\.(md|mdx)$/, "");
  const stats = readingTime(post.body || "");
  return {
    id: post.id,
    slug: slug,
    title: post.data.title,
    description: post.data.description,
    date: post.data.date,
    updated: post.data.updated,
    type: post.data.type,
    status: post.data.status,
    tags: post.data.tags || [],
    image: post.data.image,
    draft: post.data.draft,
    readingTimeText: stats.text,
    parent: post.data.parent,
  };
});

// Group posts by parent relationship
const childrenByParent = new Map<string, typeof allPostsData>();
allPostsData.forEach((post) => {
  if (post.parent) {
    if (!childrenByParent.has(post.parent)) {
      childrenByParent.set(post.parent, []);
    }
    childrenByParent.get(post.parent)!.push(post);
  }
});

// Create hierarchical structure: top-level posts with their children
const hierarchicalPosts = allPostsData
  .filter((post) => !post.parent) // Only top-level posts
  .map((post) => {
    const children = childrenByParent.get(post.slug) || [];
    // Sort children chronologically (oldest to newest)
    children.sort((a, b) => {
      const aDate = a.date;
      const bDate = b.date;
      return new Date(aDate || 0).valueOf() - new Date(bDate || 0).valueOf();
    });
    return {
      ...post,
      children,
    };
  });
---

<BaseLayout title="Ideas">
  <header class="space-y-8 animate-slide-in">
    <div class="space-y-4 py-10">
      <h1 class="font-serif text-4xl font-semibold tracking-tight text-text-base sm:text-5xl dark:text-text-light">
        Digital Garden
      </h1>
      <p class="max-w-2xl text-lg text-muted dark:text-muted-dark">
        The notes, thoughts, and projects I've been working on.
      </p>
    </div>

    <div class="js-required space-y-6">
      <div class="flex flex-col gap-4 sm:flex-row sm:items-center">
        <label class="sr-only" for="type-filter">Filter by type</label>
        <select
          id="type-filter"
          class="flex-1 rounded-lg border border-border-light bg-surface-light px-4 py-2 text-sm capitalize text-text-base shadow-soft transition focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/40 dark:border-border-dark dark:bg-surface-dark dark:text-text-light"
        >
          <option value="all">All types</option>
          {allTypes.map((type) => <option value={type}>{capitalize(type || '')}</option>)}
        </select>

        <label class="sr-only" for="status-filter">Filter by status</label>
        <select
          id="status-filter"
          class="flex-1 rounded-lg border border-border-light bg-surface-light px-4 py-2 text-sm capitalize text-text-base shadow-soft transition focus:border-accent focus:outline-none focus:ring-2 focus:ring-accent/40 dark:border-border-dark dark:bg-surface-dark dark:text-text-light"
        >
          <option value="all">All statuses</option>
          {
            allStatuses.map((status) => (
              <option value={status}>{capitalize(status || '')}</option>
            ))
          }
        </select>
      </div>

      <div class="filters" data-pagefind-ignore>
        <ul class="tag-list flex flex-wrap gap-2">
          <li>
            <button
              type="button"
              id="all-tags"
              class="rounded-full border border-border-light px-3 py-1 text-sm capitalize text-muted transition-colors duration-200 hover:border-accent hover:text-text-base focus:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 dark:border-border-dark dark:text-muted-dark dark:hover:text-text-light"
              class:list={{
                "border-transparent": true,
                "bg-accent": true,
                "ring-2": true,
                "ring-accent/40": true,
                "text-site-light": true,
              }}
              aria-pressed="true"
            >
              All Topics
            </button>
          </li>
          {
            allTags.map((tag) => (
              <li>
                <button
                  type="button"
                  data-tag={tag}
                  class="rounded-full border border-border-light px-3 py-1 text-sm capitalize text-muted transition-colors duration-200 hover:border-accent hover:text-text-base focus:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 dark:border-border-dark dark:text-muted-dark dark:hover:text-text-light"
                  aria-pressed="false"
                >
                  {tag}
                </button>
              </li>
            ))
          }
        </ul>
      </div>
    </div>
  </header>

  <section
    class="post-grid animate-scale-fade flex flex-col gap-8 lg:flex-row lg:items-start"
    data-pagefind-ignore
  >
    <!-- Server-rendered single column - works without JS -->
    <div class="masonry-column flex w-full flex-col gap-8 lg:flex-1" data-column="0">
      {
        hierarchicalPosts.map((post) => {
        const typeClass = post.type ? `post-card--${post.type}` : '';
        const isRetro = post.type === 'retro';
        const hasChildren = post.children && post.children.length > 0;

        return (
          <div
            class={`post-card ${typeClass} ${hasChildren ? "post-card--with-children" : ""} group flex w-full flex-col overflow-hidden rounded-2xl border border-border-light bg-surface-light shadow-soft transition-transform duration-200 hover:-translate-y-1 hover:shadow-xl focus-within:outline focus-within:outline-2 focus-within:outline-offset-2 focus-within:outline-accent dark:border-border-dark dark:bg-surface-dark`}
            data-parent-slug={post.slug}
            data-tags={post.tags?.join(" ")}
            data-type={post.type}
            data-status={post.status}
            data-has-parent="false"
          >
            {/* Parent post link and content */}
            <a
              href={`/ideas/${post.slug}/`}
              class="post-card-link flex flex-1 flex-col focus:outline-none"
            >
              {/* Show image at top for all posts */}
              {post.image?.path && (
                <Image
                  src={post.image.path}
                  alt={post.image.alt || ""}
                  width={800}
                  height={isRetro ? 300 : 200}
                  class:list={{
                    "h-52 w-full object-cover": true,
                    "h-72": isRetro,
                    hidden: post.type === "note",
                  }}
                />
              )}

              <div
                class="post-card-content flex flex-1 flex-col gap-4 p-6"
                class:list={{ "p-4": post.type === "note" }}
              >
                <div class="post-card-content-header flex flex-wrap items-center gap-3 text-xs uppercase tracking-wide text-muted dark:text-muted-dark">
                  {post.draft && (
                    <span class="draft-indicator inline-flex items-center rounded-md bg-yellow-400 px-2 py-0.5 text-[0.65rem] font-semibold uppercase tracking-wide text-green-900">
                      Draft
                    </span>
                  )}
                  {post.type && <span>{capitalize(post.type)}</span>}
                  {post.status && <span>{capitalize(post.status)}</span>}
                  <span>{post.readingTimeText}</span>
                </div>
                <h3
                  class="font-serif text-2xl font-semibold tracking-tight text-text-base dark:text-text-light"
                  class:list={{ "text-xl": post.type === "note", "text-3xl": isRetro }}
                >
                  {post.title}
                </h3>
                <p
                  class="text-base text-muted dark:text-muted-dark"
                  class:list={{ "text-sm": post.type === "note" }}
                >
                  {post.description}
                </p>
                <div class="post-meta mt-auto flex flex-wrap items-center justify-between gap-3 text-xs uppercase tracking-wide text-muted dark:text-muted-dark">
                  <span>
                    <FormattedDate date={post.date || new Date()} />
                  </span>
                  {post.updated && (
                    <span>
                      Updated: <FormattedDate date={post.updated} />
                    </span>
                  )}
                </div>
              </div>
            </a>

            {/* Child posts - inside the same card */}
            {hasChildren && (
              <div
                class="child-posts flex flex-col divide-y divide-border-light dark:divide-border-dark"
                data-parent={post.slug}
              >
                {post.children.map((child) => {
                  const childTypeClass = child.type ? `post-card--${child.type}` : '';

                  return (
                    <a
                      href={`/ideas/${child.slug}/`}
                      class={`child-post-item ${childTypeClass} flex gap-4 bg-transparent p-4 transition-colors duration-200 hover:bg-surface-light focus:outline-none focus-visible:ring-2 focus-visible:ring-accent/40 dark:hover:bg-surface-dark`}
                      data-tags={child.tags?.join(" ")}
                      data-type={child.type}
                      data-status={child.status}
                      data-has-parent="true"
                      data-parent-post={post.slug}
                    >
                      {/* Show image on left for child posts */}
                      {child.image?.path && (
                        <Image
                          src={child.image.path}
                          alt={child.image.alt || ""}
                          width={400}
                          height={120}
                          class:list={{
                            "h-28 w-32 flex-none rounded-lg object-cover": true,
                            hidden: child.type === "note",
                          }}
                        />
                      )}

                      <div class="child-post-content flex flex-1 flex-col gap-3">
                        <div class="post-card-content-header flex flex-wrap items-center gap-3 text-xs uppercase tracking-wide text-muted dark:text-muted-dark">
                          {child.draft && (
                            <span class="draft-indicator inline-flex items-center rounded-md bg-yellow-400 px-2 py-0.5 text-[0.65rem] font-semibold uppercase tracking-wide text-green-900">
                              Draft
                            </span>
                          )}
                          {child.type && <span>{capitalize(child.type)}</span>}
                          {child.status && <span>{capitalize(child.status)}</span>}
                          <span>{child.readingTimeText}</span>
                        </div>
                        <h3
                          class="font-serif text-lg font-semibold tracking-tight text-text-base dark:text-text-light"
                          class:list={{ "text-base": child.type === "note" }}
                        >
                          {child.title}
                        </h3>
                        <p class="text-sm text-muted dark:text-muted-dark">{child.description}</p>
                        <div class="post-meta flex flex-wrap items-center justify-between gap-3 text-xs uppercase tracking-wide text-muted dark:text-muted-dark">
                          <span>
                            <FormattedDate date={child.date || new Date()} />
                          </span>
                          {child.updated && (
                            <span>
                              Updated: <FormattedDate date={child.updated} />
                            </span>
                          )}
                        </div>
                      </div>
                    </a>
                  );
                })}
              </div>
            )}
          </div>
        );
      })
    }
    </div>
    <!-- Additional columns created by JS for masonry layout -->
    <div class="masonry-column hidden w-full flex-col gap-8 lg:flex-1" data-column="1"></div>
    <div class="masonry-column hidden w-full flex-col gap-8 lg:flex-1" data-column="2"></div>
  </section>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // Initialize masonry layout
      const postGrid = document.querySelector('.post-grid') as HTMLElement;
      const columns = Array.from(document.querySelectorAll('.masonry-column')) as HTMLElement[];

      if (!postGrid || columns.length === 0) return;

      // Enable JS-enhanced layout
      postGrid.classList.add('js-enabled');

      // Get all post items from the first column (server-rendered)
      const firstColumn = columns[0];
      const postItems = Array.from(firstColumn.querySelectorAll('.post-card')) as HTMLElement[];

      // Function to get visible columns based on screen width
      function getVisibleColumns() {
        const width = window.innerWidth;
        if (width < 768) return [columns[0]]; // Mobile: 1 column
        if (width < 1200) return [columns[0], columns[1]]; // Tablet: 2 columns
        return columns; // Desktop: 3 columns
      }

      // Distribute items into columns using "shortest column" algorithm
      function layoutMasonry() {
        const visibleColumns = getVisibleColumns();

        columns.forEach((col) => {
          col.innerHTML = '';
          if (visibleColumns.includes(col)) {
            col.classList.remove('hidden');
            col.classList.add('flex');
          } else {
            col.classList.add('hidden');
            col.classList.remove('flex');
          }
        });

        const activeColumns = visibleColumns.length ? visibleColumns : [columns[0]];

        postItems.forEach((item) => {
          const [primaryColumn] = activeColumns;
          if (!primaryColumn) {
            return;
          }

          // Skip hidden items (filtered out) - don't count toward column height
          if (item.classList.contains('hidden')) {
            primaryColumn.appendChild(item);
            return;
          }

          // Find the shortest visible column by comparing current heights
          let shortestColumn = primaryColumn;
          let shortestHeight = primaryColumn.offsetHeight;

          activeColumns.forEach((col) => {
            if (col.offsetHeight < shortestHeight) {
              shortestHeight = col.offsetHeight;
              shortestColumn = col;
            }
          });

          // Add item to shortest column
          shortestColumn.appendChild(item);
        });
      }

      // Initial layout
      layoutMasonry();

      // Re-layout on window resize (debounced)
      let resizeTimeout: ReturnType<typeof setTimeout>;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(layoutMasonry, 150);
      });

      let activeTag = "all";
      let activeType = "all";
      let activeStatus = "all";
      let activeHierarchy = "all";

      function filterPosts() {
        // Use the server-rendered postItems array
        postItems.forEach((container) => {
          // The container itself is now the post-card
          const parentTags = container.dataset.tags?.split(" ") || [];
          const parentType = container.dataset.type;
          const parentStatus = container.dataset.status;

          const parentTagMatch = activeTag === "all" || parentTags.includes(activeTag);
          const parentTypeMatch = activeType === "all" || parentType === activeType;
          const parentStatusMatch = activeStatus === "all" || parentStatus === activeStatus;

          // Check if any children match (if they exist)
          const childContainer = container.querySelector('.child-posts') as HTMLElement;
          let anyChildMatches = false;
          if (childContainer) {
            const childItems = Array.from(childContainer.querySelectorAll('.child-post-item')) as HTMLElement[];
            childItems.forEach((childItem) => {
              const childTags = childItem.dataset.tags?.split(" ") || [];
              const childType = childItem.dataset.type;
              const childStatus = childItem.dataset.status;

              const childTagMatch = activeTag === "all" || childTags.includes(activeTag);
              const childTypeMatch = activeType === "all" || childType === activeType;
              const childStatusMatch = activeStatus === "all" || childStatus === activeStatus;

              if (childTagMatch && childTypeMatch && childStatusMatch) {
                childItem.classList.remove("hidden");
                anyChildMatches = true;
              } else {
                childItem.classList.add("hidden");
              }
            });
          }

          // Show parent if it matches OR if we're showing all posts and any child matches
          const shouldShowParent = (parentTagMatch && parentTypeMatch && parentStatusMatch) ||
                                   (activeHierarchy === "all" && anyChildMatches);

          // For top-level filter, always evaluate parent normally
          if (activeHierarchy === "top-level") {
            if (parentTagMatch && parentTypeMatch && parentStatusMatch) {
              container.classList.remove("hidden");
              // Hide children in top-level mode
              if (childContainer) {
                childContainer.style.display = "none";
              }
            } else {
              container.classList.add("hidden");
            }
          } else {
            // Normal filtering: show parent and children based on matches
            if (shouldShowParent) {
              container.classList.remove("hidden");
              if (childContainer) {
                childContainer.style.display = anyChildMatches ? "flex" : "none";
              }
            } else {
              container.classList.add("hidden");
            }
          }
        });

        // Re-layout masonry after filtering to fix column distribution
        requestAnimationFrame(() => {
          layoutMasonry();
        });
      }

      // Tag filtering
      const tagButtons = document.querySelectorAll(".tag-list button");
      const ACTIVE_TAG_CLASSES = [
        "border-transparent",
        "bg-accent",
        "text-site-light",
        "ring-2",
        "ring-accent/40",
      ];

      function setTagButtonState(button: HTMLElement, isActive: boolean) {
        ACTIVE_TAG_CLASSES.forEach((cls) => {
          if (isActive) {
            button.classList.add(cls);
          } else {
            button.classList.remove(cls);
          }
        });
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      }

      tagButtons.forEach((button) => {
        const element = button as HTMLElement;
        const isInitialActive = element.id === 'all-tags';
        setTagButtonState(element, isInitialActive);

        button.addEventListener("click", () => {
          tagButtons.forEach((btn) => {
            const btnElement = btn as HTMLElement;
            setTagButtonState(btnElement, btn === button);
          });

          const b = button as HTMLElement;
          activeTag = b.id === "all-tags" ? "all" : b.dataset.tag || "all";
          filterPosts();
        });
      });

      // Type filter
      const typeFilter = document.getElementById(
        "type-filter"
      ) as HTMLSelectElement;
      if (typeFilter) {
        typeFilter.addEventListener("change", (e) => {
          activeType = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }

      // Status filter
      const statusFilter = document.getElementById(
        "status-filter"
      ) as HTMLSelectElement;
      if (statusFilter) {
        statusFilter.addEventListener("change", (e) => {
          activeStatus = (e.target as HTMLSelectElement).value;
          filterPosts();
        });
      }
    });
  </script>
</BaseLayout>

## Describing Algorithms

The skills required to eectively design and analyze algorithms are entangled with the skills required to eectively describe algorithms. At least in my classes, a complete description of any algorithm has four components:

    What: A precise specification of the problem that the algorithm solves.
    How: A precise description of the algorithm itself.
    Why: A proof that the algorithm solves the problem it is supposed to solve.
    How fast: An analysis of the running time of the algorithm.

It is not necessary (or even advisable) to develop these four components in this particular order. Problem specifications, algorithm descriptions, correctness proofs, and time analyses usually evolve simultaneously, with the development of each component informing the development of the others. For example, we may need to tweak the problem description to support a faster algorithm, or modify the algorithm to handle a tricky case in the proof of correctness. Nevertheless, presenting these components separately is usually clearest for the reader. As with any writing, it’s important to aim your descriptions at the right audience; I recommend writing for a competent but skeptical programmer who is not as clever as you are. Think of yourself six months ago. As you develop any new algorithm, you will naturally build up lots of intuition about the problem and about how your algorithm solves it, and your informal reasoning will be guided by that intuition. But anyone reading your algorithm later, or the code you derive from it, won’t share your intuition or experience. Neither will your compiler. Neither will you six months from now. All they will have is your written description. Even if you never have to explain your algorithms to anyone else, it’s still important to develop them with an audience in mind. Trying to communicate clearly forces you to think more clearly. In particular, writing for a novice audience, who will interpret your words exactly as written, forces you to work through fine details, no matter how “obvious” or “intuitive” your high-level ideas may seem at the moment. Similarly, writing for a skeptical audience forces you to develop robust arguments for correctness and eciency, instead of trusting your intuition or your intelligence. I cannot emphasize this point enough: Your primary job as an algorithm designer is teaching other people how and why your algorithms work. If you can’t communicate your ideas to other human beings, they may as well not exist. Producing correct and ecient executable code is an important but secondary goal. Convincing yourself, your professors, your (prospective) employers, your colleagues, or your students that you are smart is at best a distant third.

### Specifying the Problem

Before we can even start developing a new algorithm, we have to agree on what problem our algorithm is supposed to solve. Similarly, before we can even start describing an algorithm, we have to describe the problem that the algorithm is supposed to solve. Algorithmic problems are often presented using standard English, in terms of real-world objects. It’s up to us, the algorithm designers, to restate these problems in terms of formal, abstract, mathematical objects—numbers, arrays, lists, graphs, trees, and so on—that we can reason about formally. We must also determine if the problem statement carries any hidden assumptions, and state those assumptions explicitly. (For example, in the song “ n Bottles of Beer on the Wall”, n is always a non-negative integer.) We may need to refine our specification as we develop the algorithm. For example, our algorithm may require a particular input representation, or produce a particular output representation, that was left unspecified in the original informal problem description. Or our algorithm might actually solve a more general problem than we were originally asked to solve. (This is a common feature of recursive algorithms.) The specification should include just enough detail that someone else could use our algorithm as a black box, without knowing how or why the algorithm actually works. In particular, we must describe the type and meaning of each input parameter, and exactly how the eventual output depends on the input parameters. On the other hand, our specification should deliberately hide any details that are not necessary to use the algorithm as a black box. Let that which does not matter truly slide. In particular, I assume that you are a skeptical novice! I’ve never heard anyone sing “p 2 Bottles of Beer on the Wall.” Occasionally I have heard set theorists singing “@ 0 bottles of beer on the wall”, but for some reason they always gave up before the song was over.

For example, the lattice and duplation-and-mediation algorithms both solve the same problem: Given two non-negative integers x and y , each represented as an array of digits, compute the product x · y , also represented as an array of digits. To someone using these algorithms, the choice of algorithm is completely irrelevant. On the other hand, the Greek straightedge-and-compass algorithm solves a dierent problem , because the input and output values are represented by line segments instead of arrays of digits. 

### Describing the Algorithm

Computer programs are concrete representations of algorithms, but algorithms are not programs. Rather, algorithms are abstract mechanical procedures that can be implemented in any programming languagethat supports the underlying primitive operations. The idiosyncratic syntactic details of your favorite programming language are utterly irrelevant; focusing on these will only distract you (and your readers) from what’s really going on. A good algorithm description is closer to what we should write in the comments of a real program than the code itself. Code is a poor medium for storytelling. On the other hand, a plain English prose description is usually not a good idea either. Algorithms have lots of idiomatic structure—especially conditionals, loops, function calls, and recursion—that are far too easily hidden by unstructured prose. Colloquial English is full of ambiguities and shades of meaning, but algorithms must be described as unambiguously as possible. Prose is a poor medium for precision. In my opinion, the clearest way to present an algorithm is using a combination of pseudo code and structured English. Pseudocode uses the structure of formal programming languages and mathematics to break algorithms into primitive steps; the primitive steps themselves can be written using mathematical notation, pure English, or an appropriate mixture of the two, whatever is clearest. Well- written pseudocode reveals the internal structure of the algorithm but hides irrelevant implementation details, making the algorithm easier to understand, analyze, debug, and implement.

Whenever we describe an algorithm, our description should include every detail necessary to fully specify the algorithm, prove its correctness, and analyze its running time. At the same time, it should exclude any details that are not necessary to fully specify the algorithm, prove its correctness, and analyze its running time. (Slide.) At a more practical level, our description should allow a competent but skeptical programmer who has not read this book to quickly and correctly implement the algorithm in their favorite programming language, without understanding why it works. I don’t want to bore you with the rules I follow for writing pseudocode, but I must caution against one especially pernicious habit. Never describe repeated operations informally, as in “Do [this] first, then do [that] second, and so on .” or “Repeat this process until [something]”. As anyone who has taken one of those frustrating“What comes next in this sequence?”tests already knows, describing the first few steps of an algorithm says little or nothing about what happens in later steps. If your algorithm has a loop, write it as a loop, and explicitly describe what happens in an arbitrary iteration. Similarly, if your algorithm is recursive, write it recursively, and explicitly describe the case boundaries and what happens in each case.

## Analyzing Algorithms

It’s not enough just to write down an algorithm and say “Behold!” We must also convince our audience (and ourselves!) that the algorithm actually does what it’s supposed to do, and that it does so eciently.

### Correctness

In some application settings, it is acceptable for programs to behave correctly most of the time, on all “reasonable” inputs. Not in this book; we require algorithms that are always correct, for all possible inputs. Moreover, we must prove that our algorithms are correct; trusting our instincts, or trying a few test cases, isn’t good enough. Sometimes correctness is truly obvious, especially for algorithms you’ve seen in earlier courses. On the other hand, “obvious” is all too often a synonym for “wrong”. Most of the algorithms we discuss in this course require real work to prove correct. In particular, correctness proofs usually involve induction. We like induction. Induction is our friend . Of course, before we can formally prove that our algorithm does what it’s supposed to do, we have to formally describe what it’s supposed to do!

If induction is not your friend, you will have a hard time with this book.

￿￿

￿.6. Analyzing Algorithms

Running Time

The most common way of ranking dierent algorithms for the same problem is by how quickly they run. Ideally, we want the fastest possible algorithm for any particular problem. In many application settings, it is acceptable for programs to run eciently most of the time, on all “reasonable” inputs. Not in this book; we require algorithms that always run eciently, even in the worst case. But how do we measure running time? As a specific example, how long does it take to sing the songBOB( n )? This is obviously a function of the input value n , but it also depends on how quickly you can sing. Some singers might take ten seconds to sing a verse; others might take twenty. Technology widens the possibilities even further. Dictating the song over a telegraph using Morse code might take a full minute per verse. Downloading an mpover the Web might take a tenth of a second per verse. Duplicating the mpin a computer’s main memory might take only a few microseconds per verse. What’s important here is how the singing time changes as n grows. Singing BOB( 2 n )requires about twice much time as singingBO- B( n ), no matter what technology is being used. This is reflected in the asymptotic singing time ⇥ ( n ). We can measure time by counting how many times the algorithm executes a certain instruction or reaches a certain milestone in the “code”. For example, we might notice that the word “beer” is sung three times in every verse of BOB, so the number of times you sing “beer” is a good indication of the total singing time. For this question, we can give an exact answer: BOB( n )mentionsbeerexactly 3 n + 3 times. Incidentally, there are lots of songs with quadratic singing time. This one is probably familiar to most English-speakers:

NDOC( gifts [2.. n ]): for i 1 to n Sing “ On theith day of Christmas, my true love gave to me ” for j i down to 2 Sing “ j gifts [ j ] , ” if i> 1 Sing “ and ” Sing “ apartridgeinapeartree. ”

The input toNDOCis a list of n 1 gifts, represented here as an array. It’s quite easy to show that the singing time is ⇥ ( n^2 ); in particular, the singer mentions the name of a gift

P n i = 1 i = n ( n +^1 ) /^2 times (counting the partridge in the pear tree). It’s also easy to see that during the first n days of Christmas, my true love gave to me exactly

P n i = 1

P i j = 1 j = n ( n +^1 )( n +^2 ) /^6 = ⇥ ( n^3 )gifts.

Other quadratic-time songs include “Old MacDonald Had a Farm”, “There Was an Old Lady Who Swallowed a Fly”, “Hole in the Bottom of the Sea”, “Green Grow the Rushes O”, “The Rattlin’ Bog”, “The Court Of King Caractacus”,“The Barley-Mow”, “If I Were Not Upon the Stage”, “Star Trekkin’ ”,“Ist das nicht ein Schnitzelbank?”,“Il Pulcino Pio”, “Minkurinn í hænsnakofanum”, “Echad Mi Yodea”, and “ ”. For more examples, consult your favorite preschooler. A( lapart [1.. n ]): Chantez «Alouette,gentillealouette,alouette,jeteplumerai.» pour tout i de 1 à n Chantez «Jeteplumerailapart [ i ] .Jeteplumerailapart [ i ] .» pour tout j de i à 1 hh àrebours ii Chantez «Etlapart [ j ] !Etlapart [ j ] !» Chantez «Alouette!Alouette!Aaaaaa...» Chantez «...alouette,gentilleallouette,alouette,jeteplumerai.»

A few songs have even more bizarre singing times. A fairly modern example is “The TELNET Song” by Guy Steele, which actually takes ⇥ ( 2 n )time to sing the first n verses; Steele recommended n = 4. Finally, there are some songs that never end. Except for “The TELNET Song”, all of these songs are most naturally expressed as a small set of nested loops, so theirrunningsinging times can be computed using nested summations. The running time of a recursive algorithm is more easily expressed as a recurrence. For example, the peasant multiplication algorithm can be expressed recursively as follows:

x · y =

8

> < :

0 if x = 0 b x/ 2 c·( y + y ) if x is even b x/ 2 c·( y + y )+ y if x is odd

Let T ( x , y )denote the number of parity, addition, and mediation operations required to compute x · y. This function satisfies the recursive inequality T ( x , y ) T (b x/ 2 c,2 y )+ 2 with base case T (0, y )= 0. Techniques described in the next chapter imply the upper bound T ( x , y )= O (log x ). Sometimes the running time of an algorithm depends on a particular implementation of some underlying data structure of subroutine. For example, the Huntington-Hill apportionment algorithmACruns in O ( N + RI +( R n ) E )time, where N denotes the running time ofNP- Q, I denotes the running time ofI, and E denotes the running time Ja, das ist Otto von Schnitzelpusskrankengescheitmeyer! They just go on and on, my friend.
